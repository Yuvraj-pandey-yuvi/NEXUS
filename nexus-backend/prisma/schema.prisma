// Nexus Platform Database Schema
// This schema represents the complete hybrid Web2/Web3 social platform

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============= USER MANAGEMENT =============

model User {
  id                String   @id @default(cuid())
  email             String?  @unique
  username          String   @unique
  displayName       String
  bio               String?
  profileImage      String?
  walletAddress     String?  @unique
  googleId          String?  @unique
  
  // Authentication & Sessions
  hashedPassword    String?
  emailVerified     Boolean  @default(false)
  isActive          Boolean  @default(true)
  lastLogin         DateTime?
  
  // Reputation & Analytics
  reputation        Int      @default(0)
  totalLikes        Int      @default(0)
  totalFollowers    Int      @default(0)
  totalFollowing    Int      @default(0)
  
  // Web3 Features
  isWeb3Verified    Boolean  @default(false)
  freeAnchorsUsed   Int      @default(0)
  lastAnchorReset   DateTime @default(now())
  
  // Timestamps
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Relations
  posts             Post[]
  communities       CommunityMember[]
  ownedCommunities  Community[]       @relation("CommunityOwner")
  likes             Like[]
  follows           Follow[]          @relation("Follower")
  followers         Follow[]          @relation("Following")
  votes             ModerationVote[]
  nftListings       NFTListing[]
  transactions      Transaction[]
  anchors           PostAnchor[]
  
  @@map("users")
}

model Follow {
  id          String @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())
  
  follower    User @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  following   User @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)
  
  @@unique([followerId, followingId])
  @@map("follows")
}

// ============= CONTENT MANAGEMENT =============

enum PostType {
  TEXT
  IMAGE
  VIDEO
  POLL
}

enum PostStatus {
  DRAFT
  PUBLISHED
  ANCHORED
  MINTED
  DELISTED
}

model Post {
  id              String     @id @default(cuid())
  authorId        String
  content         String
  mediaUrls       String[]   // Array for multiple media files
  type            PostType   @default(TEXT)
  status          PostStatus @default(PUBLISHED)
  
  // Engagement Metrics
  likesCount      Int        @default(0)
  commentsCount   Int        @default(0)
  sharesCount     Int        @default(0)
  
  // Web3 Features
  isAnchored      Boolean    @default(false)
  isMinted        Boolean    @default(false)
  tokenId         String?    @unique
  contractAddress String?
  ipfsHash        String?
  
  // Timestamps
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  anchoredAt      DateTime?
  mintedAt        DateTime?
  
  // Relations
  author          User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  likes           Like[]
  comments        Comment[]
  anchors         PostAnchor[]
  communityPosts  CommunityPost[]
  nftListing      NFTListing?
  moderationFlags ModerationFlag[]
  
  @@map("posts")
}

model PostAnchor {
  id              String   @id @default(cuid())
  postId          String
  userId          String
  transactionHash String   @unique
  blockNumber     Int
  gasUsed         String
  anchoredAt      DateTime @default(now())
  
  post            Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("post_anchors")
}

model Like {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  createdAt DateTime @default(now())
  
  // Batching for on-chain likes
  isBatched Boolean  @default(false)
  batchId   String?
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  @@unique([userId, postId])
  @@map("likes")
}

model Comment {
  id        String   @id @default(cuid())
  postId    String
  authorId  String
  content   String
  createdAt DateTime @default(now())
  
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  @@map("comments")
}

// ============= COMMUNITY DAO FEATURES =============

enum CommunityType {
  FREE
  TOKEN_GATED
  NFT_GATED
}

model Community {
  id              String        @id @default(cuid())
  name            String        @unique
  description     String
  imageUrl        String?
  bannerUrl       String?
  type            CommunityType @default(FREE)
  
  // Access Control
  entryFee        String?       // Wei amount for token-gated
  requiredNFT     String?       // Contract address for NFT-gated
  
  // DAO Features
  treasuryAddress String?
  votingPower     String        @default("EQUAL") // EQUAL, TOKEN_WEIGHTED, NFT_WEIGHTED
  
  // Analytics
  memberCount     Int           @default(0)
  totalPosts      Int           @default(0)
  
  // Timestamps
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations
  ownerId         String
  owner           User          @relation("CommunityOwner", fields: [ownerId], references: [id])
  members         CommunityMember[]
  posts           CommunityPost[]
  proposals       Proposal[]
  roles           CommunityRole[]
  
  @@map("communities")
}

enum MembershipStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

model CommunityMember {
  id          String           @id @default(cuid())
  userId      String
  communityId String
  status      MembershipStatus @default(ACTIVE)
  joinedAt    DateTime         @default(now())
  
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  community   Community        @relation(fields: [communityId], references: [id], onDelete: Cascade)
  roles       CommunityMemberRole[]
  
  @@unique([userId, communityId])
  @@map("community_members")
}

model CommunityPost {
  id          String    @id @default(cuid())
  postId      String
  communityId String
  isPinned    Boolean   @default(false)
  createdAt   DateTime  @default(now())
  
  post        Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  community   Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  
  @@unique([postId, communityId])
  @@map("community_posts")
}

// ============= DAO GOVERNANCE =============

enum ProposalType {
  FUNDING
  GOVERNANCE
  BOUNTY
  GENERAL
}

enum ProposalStatus {
  DRAFT
  ACTIVE
  PASSED
  FAILED
  EXECUTED
}

model Proposal {
  id              String         @id @default(cuid())
  communityId     String
  title           String
  description     String
  type            ProposalType   @default(GENERAL)
  status          ProposalStatus @default(DRAFT)
  
  // Voting Configuration
  votingStartsAt  DateTime
  votingEndsAt    DateTime
  requiredQuorum  Int            @default(50) // Percentage
  passingThreshold Int           @default(50) // Percentage
  gasRequired     Boolean        @default(false)
  
  // Results
  yesVotes        Int            @default(0)
  noVotes         Int            @default(0)
  totalVotes      Int            @default(0)
  
  // Blockchain
  transactionHash String?
  executedAt      DateTime?
  
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  
  community       Community      @relation(fields: [communityId], references: [id], onDelete: Cascade)
  votes           ProposalVote[]
  
  @@map("proposals")
}

model ProposalVote {
  id         String   @id @default(cuid())
  proposalId String
  userId     String
  vote       Boolean  // true = yes, false = no
  weight     Int      @default(1)
  createdAt  DateTime @default(now())
  
  proposal   Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  
  @@unique([proposalId, userId])
  @@map("proposal_votes")
}

// ============= ROLE & PERMISSIONS =============

model CommunityRole {
  id          String   @id @default(cuid())
  communityId String
  name        String
  description String?
  permissions String[] // JSON array of permissions
  nftRequired String?  // Contract address + token ID
  color       String   @default("#6366f1")
  
  community   Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  members     CommunityMemberRole[]
  
  @@unique([communityId, name])
  @@map("community_roles")
}

model CommunityMemberRole {
  id       String @id @default(cuid())
  memberId String
  roleId   String
  
  member   CommunityMember @relation(fields: [memberId], references: [id], onDelete: Cascade)
  role     CommunityRole   @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  @@unique([memberId, roleId])
  @@map("community_member_roles")
}

// ============= NFT MARKETPLACE =============

enum ListingStatus {
  ACTIVE
  SOLD
  CANCELLED
  EXPIRED
}

model NFTListing {
  id              String        @id @default(cuid())
  postId          String        @unique
  sellerId        String
  price           String        // Wei amount
  currency        String        @default("MATIC")
  status          ListingStatus @default(ACTIVE)
  
  // Marketplace metadata
  views           Int           @default(0)
  favorites       Int           @default(0)
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  expiresAt       DateTime?
  soldAt          DateTime?
  
  post            Post          @relation(fields: [postId], references: [id], onDelete: Cascade)
  seller          User          @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  transactions    Transaction[]
  
  @@map("nft_listings")
}

enum TransactionType {
  PURCHASE
  TRANSFER
  MINT
  BURN
}

model Transaction {
  id              String          @id @default(cuid())
  listingId       String?
  buyerId         String?
  sellerId        String?
  type            TransactionType
  amount          String          // Wei amount
  platformFee     String          // Wei amount
  transactionHash String          @unique
  blockNumber     Int
  gasUsed         String
  
  createdAt       DateTime        @default(now())
  
  listing         NFTListing?     @relation(fields: [listingId], references: [id])
  buyer           User?           @relation(fields: [buyerId], references: [id])
  
  @@map("transactions")
}

// ============= MODERATION SYSTEM =============

enum FlagReason {
  SPAM
  HARASSMENT
  HATE_SPEECH
  VIOLENCE
  COPYRIGHT
  ADULT_CONTENT
  MISINFORMATION
  OTHER
}

enum FlagStatus {
  PENDING
  UNDER_REVIEW
  APPROVED
  REJECTED
}

model ModerationFlag {
  id          String     @id @default(cuid())
  postId      String
  reporterId  String?    // Can be anonymous
  reason      FlagReason
  description String?
  status      FlagStatus @default(PENDING)
  
  createdAt   DateTime   @default(now())
  reviewedAt  DateTime?
  
  post        Post       @relation(fields: [postId], references: [id], onDelete: Cascade)
  votes       ModerationVote[]
  
  @@map("moderation_flags")
}

model ModerationVote {
  id      String @id @default(cuid())
  flagId  String
  voterId String
  vote    Boolean // true = flag content, false = keep content
  
  createdAt DateTime @default(now())
  
  flag    ModerationFlag @relation(fields: [flagId], references: [id], onDelete: Cascade)
  voter   User           @relation(fields: [voterId], references: [id], onDelete: Cascade)
  
  @@unique([flagId, voterId])
  @@map("moderation_votes")
}

// ============= SYSTEM & ANALYTICS =============

model BatchLikes {
  id              String   @id @default(cuid())
  postId          String
  likeCount       Int
  transactionHash String?
  batchedAt       DateTime @default(now())
  processedAt     DateTime?
  
  @@map("batch_likes")
}

model SystemConfig {
  id    String @id @default(cuid())
  key   String @unique
  value String
  
  updatedAt DateTime @updatedAt
  
  @@map("system_config")
}

// ============= NOTIFICATIONS =============

enum NotificationType {
  LIKE
  COMMENT
  FOLLOW
  MENTION
  COMMUNITY_INVITE
  PROPOSAL_CREATED
  PROPOSAL_PASSED
  NFT_SOLD
  MODERATION_ALERT
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json?            // Additional data for the notification
  read      Boolean          @default(false)
  
  createdAt DateTime         @default(now())
  
  @@map("notifications")
}